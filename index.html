<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>暗号化・復号化ツール</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.16/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="p-6">
  <div class="flex flex-col space-y-4">
    <textarea id="inputText" class="p-2 border rounded-md" placeholder="文章を入力してください"></textarea>
    <button id="encryptButton" class="p-2 bg-blue-500 text-white rounded-md">暗号化</button>
    <input id="encryptedFile" type="file" class="p-2 border rounded-md">
    <input id="publicKeyFile" type="file" class="p-2 border rounded-md">
    <input id="privateKeyFile" type="file" class="p-2 border rounded-md">
    <button id="decryptButton" class="p-2 bg-green-500 text-white rounded-md">復号化</button>
    <textarea id="outputText" class="p-2 border rounded-md" placeholder="結果がここに表示されます" readonly></textarea>
  </div>

  <script>
    // RSA-OAEPキーペアを生成します
    let keyPair;
    window.crypto.subtle.generateKey(
      {
        name: "RSA-OAEP",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: "SHA-256"
      },
      true,
      ["encrypt", "decrypt"]
    ).then(keys => {
      keyPair = keys;
    });

    // 暗号化ボタンのクリックイベントを設定します
    document.getElementById('encryptButton').addEventListener('click', () => {
      const text = document.getElementById('inputText').value;
      const encoder = new TextEncoder();
      const data = encoder.encode(text);

      window.crypto.subtle.encrypt(
        {
          name: "RSA-OAEP"
        },
        keyPair.publicKey,
        data
      ).then(encryptedData => {
        const encryptedText = btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedData)));
        document.getElementById('outputText').value = encryptedText;

        // 現在の日時を取得し、それをファイル名に使用します
        const timestamp = new Date().toISOString();

        // 暗号化されたテキストを含むBlobを作成します
        const blob = new Blob([encryptedText], {type: "text/plain;charset=utf-8"});

        // BlobからURLを作成します
        const url = URL.createObjectURL(blob);

        // ダウンロードリンクを作成し、クリックイベントを発火させます
        const link = document.createElement('a');
        link.href = url;
        link.download = `${timestamp}_encrypted.txt`;
        link.click();

        // 公開鍵と秘密鍵をエクスポートします
        const publicKeyPromise = window.crypto.subtle.exportKey("spki", keyPair.publicKey);
        const privateKeyPromise = window.crypto.subtle.exportKey("pkcs8", keyPair.privateKey);

        Promise.all([publicKeyPromise, privateKeyPromise]).then(([publicKey, privateKey]) => {
          // 公開鍵と秘密鍵をBase64エンコードします
          const publicKeyBase64 = arrayBufferToBase64(publicKey);
          const privateKeyBase64 = arrayBufferToBase64(privateKey);

          // Base64エンコードされた公開鍵と秘密鍵にPEMヘッダとフッタを追加します
          const publicKeyPem = 
            "-----BEGIN PUBLIC KEY-----\n" +
            publicKeyBase64.match(/.{1,64}/g).join('\n') +
            "\n-----END PUBLIC KEY-----\n";
          const privateKeyPem = 
            "-----BEGIN PRIVATE KEY-----\n" +
            privateKeyBase64.match(/.{1,64}/g).join('\n') +
            "\n-----END PRIVATE KEY-----\n";

          // PEM形式の公開鍵と秘密鍵を含むBlobを作成します
          const publicKeyBlob = new Blob([publicKeyPem], {type: "application/x-pem-file;charset=utf-8"});
          const privateKeyBlob = new Blob([privateKeyPem], {type: "application/x-pem-file;charset=utf-8"});

          // BlobからURLを作成します
          const publicKeyUrl = URL.createObjectURL(publicKeyBlob);
          const privateKeyUrl = URL.createObjectURL(privateKeyBlob);

          // ダウンロードリンクを作成し、クリックイベントを発火させます
          const publicKeyLink = document.createElement('a');
          publicKeyLink.href = publicKeyUrl;
          publicKeyLink.download = `${timestamp}_public_key.pem`;
          publicKeyLink.click();

          const privateKeyLink = document.createElement('a');
          privateKeyLink.href = privateKeyUrl;
          privateKeyLink.download = `${timestamp}_private_key.pem`;
          privateKeyLink.click();
        });
      });
    });

    // 復号化ボタンのクリックイベントを設定します
    document.getElementById('decryptButton').addEventListener('click', () => {
      const encryptedFile = document.getElementById('encryptedFile').files[0];
      const publicKeyFile = document.getElementById('publicKeyFile').files[0];
      const privateKeyFile = document.getElementById('privateKeyFile').files[0];

      const encryptedFilePromise = encryptedFile.arrayBuffer();
      const publicKeyFilePromise = publicKeyFile.arrayBuffer();
      const privateKeyFilePromise = privateKeyFile.arrayBuffer();

      Promise.all([encryptedFilePromise, publicKeyFilePromise, privateKeyFilePromise]).then(([encryptedData, publicKeyData, privateKeyData]) => {
        const encryptedText = new TextDecoder().decode(encryptedData);
        const publicKey = window.crypto.subtle.importKey("spki", publicKeyData, {name: "RSA-OAEP", hash: "SHA-256"}, true, ["encrypt"]);
        const privateKey = window.crypto.subtle.importKey("pkcs8", privateKeyData, {name: "RSA-OAEP", hash: "SHA-256"}, true, ["decrypt"]);

        Promise.all([publicKey, privateKey]).then(([publicKey, privateKey]) => {
          window.crypto.subtle.decrypt(
            {
              name: "RSA-OAEP"
            },
            privateKey,
            Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0))
          ).then(decryptedData => {
            const decryptedText = new TextDecoder().decode(decryptedData);
            document.getElementById('outputText').value = decryptedText;
          });
        });
      });
    });

    // ArrayBufferをBase64エンコードする関数
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }
  </script>
</body>
</html>